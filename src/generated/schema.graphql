### This file was autogenerated by Nexus 0.11.7
### Do not make changes to this file directly


type Account {
  createdAt: DateTime!
  email: String!
  id: ID!
  lastLogin: DateTime
  lastSeen: String
  role: Role!
  updatedAt: DateTime!
  username: String
}

type AccountConnection {
  aggregate: AggregateAccount!
  edges: [AccountEdge!]!
  pageInfo: PageInfo!
}

type AccountEdge {
  cursor: String!
  node: Account!
}

enum AccountOrderByInput {
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  id_ASC
  id_DESC
  isVerified_ASC
  isVerified_DESC
  lastLogin_ASC
  lastLogin_DESC
  password_ASC
  password_DESC
  role_ASC
  role_DESC
  updatedAt_ASC
  updatedAt_DESC
  username_ASC
  username_DESC
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  email: String
  email_contains: String
  email_ends_with: String
  email_gt: String
  email_gte: String
  email_in: [String!]
  email_lt: String
  email_lte: String
  email_not: String
  email_not_contains: String
  email_not_ends_with: String
  email_not_in: [String!]
  email_not_starts_with: String
  email_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  isVerified: Boolean
  isVerified_not: Boolean
  lastLogin: DateTime
  lastLogin_gt: DateTime
  lastLogin_gte: DateTime
  lastLogin_in: [DateTime!]
  lastLogin_lt: DateTime
  lastLogin_lte: DateTime
  lastLogin_not: DateTime
  lastLogin_not_in: [DateTime!]
  NOT: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  password: String
  password_contains: String
  password_ends_with: String
  password_gt: String
  password_gte: String
  password_in: [String!]
  password_lt: String
  password_lte: String
  password_not: String
  password_not_contains: String
  password_not_ends_with: String
  password_not_in: [String!]
  password_not_starts_with: String
  password_starts_with: String
  role: Role
  role_in: [Role!]
  role_not: Role
  role_not_in: [Role!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
  username: String
  username_contains: String
  username_ends_with: String
  username_gt: String
  username_gte: String
  username_in: [String!]
  username_lt: String
  username_lte: String
  username_not: String
  username_not_contains: String
  username_not_ends_with: String
  username_not_in: [String!]
  username_not_starts_with: String
  username_starts_with: String
}

input AccountWhereUniqueInput {
  email: String
  id: ID
  username: String
}

type AggregateAccount {
  count: Int!
}

type AggregateGeocode {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateOwner {
  count: Int!
}

type AggregateSchool {
  count: Int!
}

type AggregateToken {
  count: Int!
}

scalar DateTime

type Geocode {
  id: ID!
  latitude: Float!
  longitude: Float!
}

type GeocodeConnection {
  aggregate: AggregateGeocode!
  edges: [GeocodeEdge!]!
  pageInfo: PageInfo!
}

input GeocodeCreateInput {
  id: ID
  latitude: Float!
  longitude: Float!
}

type GeocodeEdge {
  cursor: String!
  node: Geocode!
}

enum GeocodeOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  latitude_ASC
  latitude_DESC
  longitude_ASC
  longitude_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input GeocodeWhereInput {
  AND: [GeocodeWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  latitude: Float
  latitude_gt: Float
  latitude_gte: Float
  latitude_in: [Float!]
  latitude_lt: Float
  latitude_lte: Float
  latitude_not: Float
  latitude_not_in: [Float!]
  longitude: Float
  longitude_gt: Float
  longitude_gte: Float
  longitude_in: [Float!]
  longitude_lt: Float
  longitude_lte: Float
  longitude_not: Float
  longitude_not_in: [Float!]
  NOT: [GeocodeWhereInput!]
  OR: [GeocodeWhereInput!]
}

input GeocodeWhereUniqueInput {
  id: ID
}

type Location {
  city: String!
  country: String!
  geocode: Geocode
  id: ID!
  nearestLandmark: String
  number: String!
  other: String
  postalCode: String!
  street: String!
}

type LocationConnection {
  aggregate: AggregateLocation!
  edges: [LocationEdge!]!
  pageInfo: PageInfo!
}

input LocationCreateInput {
  city: String!
  country: String!
  geocode: GeocodeCreateInput!
  nearestLandmark: String!
  number: String!
  other: String
  postalCode: String!
  street: String!
}

type LocationEdge {
  cursor: String!
  node: Location!
}

enum LocationOrderByInput {
  city_ASC
  city_DESC
  country_ASC
  country_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  nearestLandmark_ASC
  nearestLandmark_DESC
  number_ASC
  number_DESC
  other_ASC
  other_DESC
  postalCode_ASC
  postalCode_DESC
  street_ASC
  street_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input LocationWhereInput {
  AND: [LocationWhereInput!]
  city: String
  city_contains: String
  city_ends_with: String
  city_gt: String
  city_gte: String
  city_in: [String!]
  city_lt: String
  city_lte: String
  city_not: String
  city_not_contains: String
  city_not_ends_with: String
  city_not_in: [String!]
  city_not_starts_with: String
  city_starts_with: String
  country: String
  country_contains: String
  country_ends_with: String
  country_gt: String
  country_gte: String
  country_in: [String!]
  country_lt: String
  country_lte: String
  country_not: String
  country_not_contains: String
  country_not_ends_with: String
  country_not_in: [String!]
  country_not_starts_with: String
  country_starts_with: String
  geocode: GeocodeWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  nearestLandmark: String
  nearestLandmark_contains: String
  nearestLandmark_ends_with: String
  nearestLandmark_gt: String
  nearestLandmark_gte: String
  nearestLandmark_in: [String!]
  nearestLandmark_lt: String
  nearestLandmark_lte: String
  nearestLandmark_not: String
  nearestLandmark_not_contains: String
  nearestLandmark_not_ends_with: String
  nearestLandmark_not_in: [String!]
  nearestLandmark_not_starts_with: String
  nearestLandmark_starts_with: String
  NOT: [LocationWhereInput!]
  number: String
  number_contains: String
  number_ends_with: String
  number_gt: String
  number_gte: String
  number_in: [String!]
  number_lt: String
  number_lte: String
  number_not: String
  number_not_contains: String
  number_not_ends_with: String
  number_not_in: [String!]
  number_not_starts_with: String
  number_starts_with: String
  OR: [LocationWhereInput!]
  other: String
  other_contains: String
  other_ends_with: String
  other_gt: String
  other_gte: String
  other_in: [String!]
  other_lt: String
  other_lte: String
  other_not: String
  other_not_contains: String
  other_not_ends_with: String
  other_not_in: [String!]
  other_not_starts_with: String
  other_starts_with: String
  postalCode: String
  postalCode_contains: String
  postalCode_ends_with: String
  postalCode_gt: String
  postalCode_gte: String
  postalCode_in: [String!]
  postalCode_lt: String
  postalCode_lte: String
  postalCode_not: String
  postalCode_not_contains: String
  postalCode_not_ends_with: String
  postalCode_not_in: [String!]
  postalCode_not_starts_with: String
  postalCode_starts_with: String
  street: String
  street_contains: String
  street_ends_with: String
  street_gt: String
  street_gte: String
  street_in: [String!]
  street_lt: String
  street_lte: String
  street_not: String
  street_not_contains: String
  street_not_ends_with: String
  street_not_in: [String!]
  street_not_starts_with: String
  street_starts_with: String
}

input LocationWhereUniqueInput {
  id: ID
}

type Mutation {
  createOwner(firstName: String!, lastName: String!, middleName: String): Owner
  createSchool(email: String!, location: LocationCreateInput, phone: String!, title: String!, uri: String!): School
  login(email: String!, password: String!): Account
  passwordReset(password: String!, token: String!): TriggerAction
  requestPasswordReset(email: String!): TriggerAction
  requestVerificationMail(email: String!): TriggerAction
  signout: TriggerAction
  signup(email: String!, password: String!, username: String): Account
  updateOwner(firstName: String, lastName: String, middleName: String): Owner
  updateSchool(id: ID!, school: SchoolUpdateInput!): School
  verify(token: String!): TriggerAction
}

type Owner {
  account: Account!
  createdAt: DateTime!
  firstName: String!
  id: ID!
  lastName: String!
  middleName: String
  schools(after: String, before: String, first: Int, last: Int, orderBy: SchoolOrderByInput, skip: Int, where: SchoolWhereInput): [School!]
  updatedAt: DateTime!
}

type OwnerConnection {
  aggregate: AggregateOwner!
  edges: [OwnerEdge!]!
  pageInfo: PageInfo!
}

type OwnerEdge {
  cursor: String!
  node: Owner!
}

enum OwnerOrderByInput {
  createdAt_ASC
  createdAt_DESC
  firstName_ASC
  firstName_DESC
  id_ASC
  id_DESC
  lastName_ASC
  lastName_DESC
  middleName_ASC
  middleName_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input OwnerWhereInput {
  account: AccountWhereInput
  AND: [OwnerWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  firstName: String
  firstName_contains: String
  firstName_ends_with: String
  firstName_gt: String
  firstName_gte: String
  firstName_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_not: String
  firstName_not_contains: String
  firstName_not_ends_with: String
  firstName_not_in: [String!]
  firstName_not_starts_with: String
  firstName_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  lastName: String
  lastName_contains: String
  lastName_ends_with: String
  lastName_gt: String
  lastName_gte: String
  lastName_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_not: String
  lastName_not_contains: String
  lastName_not_ends_with: String
  lastName_not_in: [String!]
  lastName_not_starts_with: String
  lastName_starts_with: String
  location: LocationWhereInput
  middleName: String
  middleName_contains: String
  middleName_ends_with: String
  middleName_gt: String
  middleName_gte: String
  middleName_in: [String!]
  middleName_lt: String
  middleName_lte: String
  middleName_not: String
  middleName_not_contains: String
  middleName_not_ends_with: String
  middleName_not_in: [String!]
  middleName_not_starts_with: String
  middleName_starts_with: String
  NOT: [OwnerWhereInput!]
  OR: [OwnerWhereInput!]
  schools_every: SchoolWhereInput
  schools_none: SchoolWhereInput
  schools_some: SchoolWhereInput
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input OwnerWhereUniqueInput {
  id: ID
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  account(where: AccountWhereUniqueInput!): Account
  accounts(after: String, before: String, first: Int, last: Int, orderBy: AccountOrderByInput, skip: Int, where: AccountWhereInput): [Account!]!
  accountsConnection(after: String, before: String, first: Int, last: Int, orderBy: AccountOrderByInput, skip: Int, where: AccountWhereInput): AccountConnection!
  geocode(where: GeocodeWhereUniqueInput!): Geocode
  geocodes(after: String, before: String, first: Int, last: Int, orderBy: GeocodeOrderByInput, skip: Int, where: GeocodeWhereInput): [Geocode!]!
  geocodesConnection(after: String, before: String, first: Int, last: Int, orderBy: GeocodeOrderByInput, skip: Int, where: GeocodeWhereInput): GeocodeConnection!
  getOwner: Owner
  location(where: LocationWhereUniqueInput!): Location
  locations(after: String, before: String, first: Int, last: Int, orderBy: LocationOrderByInput, skip: Int, where: LocationWhereInput): [Location!]!
  locationsConnection(after: String, before: String, first: Int, last: Int, orderBy: LocationOrderByInput, skip: Int, where: LocationWhereInput): LocationConnection!
  me: Account
  owner(where: OwnerWhereUniqueInput!): Owner
  owners(after: String, before: String, first: Int, last: Int, orderBy: OwnerOrderByInput, skip: Int, where: OwnerWhereInput): [Owner!]!
  ownersConnection(after: String, before: String, first: Int, last: Int, orderBy: OwnerOrderByInput, skip: Int, where: OwnerWhereInput): OwnerConnection!
  school(where: SchoolWhereUniqueInput!): School
  schools(after: String, before: String, first: Int, last: Int, orderBy: SchoolOrderByInput, skip: Int, where: SchoolWhereInput): [School!]!
  schoolsConnection(after: String, before: String, first: Int, last: Int, orderBy: SchoolOrderByInput, skip: Int, where: SchoolWhereInput): SchoolConnection!
  token(where: TokenWhereUniqueInput!): Token
  tokens(after: String, before: String, first: Int, last: Int, orderBy: TokenOrderByInput, skip: Int, where: TokenWhereInput): [Token!]!
  tokensConnection(after: String, before: String, first: Int, last: Int, orderBy: TokenOrderByInput, skip: Int, where: TokenWhereInput): TokenConnection!
}

enum Role {
  ADMIN
  OWNER
  PARENT
  STUDENT
}

type School {
  createdAt: DateTime!
  email: String!
  id: ID!
  locations(after: String, before: String, first: Int, last: Int, orderBy: LocationOrderByInput, skip: Int, where: LocationWhereInput): [Location!]
  owner: Owner!
  phone: String!
  title: String!
  updatedAt: DateTime!
  uri: String!
}

type SchoolConnection {
  aggregate: AggregateSchool!
  edges: [SchoolEdge!]!
  pageInfo: PageInfo!
}

type SchoolEdge {
  cursor: String!
  node: School!
}

enum SchoolOrderByInput {
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  id_ASC
  id_DESC
  phone_ASC
  phone_DESC
  title_ASC
  title_DESC
  updatedAt_ASC
  updatedAt_DESC
  uri_ASC
  uri_DESC
}

input SchoolUpdateInput {
  email: String
  phone: String
  title: String
  uri: String
}

input SchoolWhereInput {
  AND: [SchoolWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  email: String
  email_contains: String
  email_ends_with: String
  email_gt: String
  email_gte: String
  email_in: [String!]
  email_lt: String
  email_lte: String
  email_not: String
  email_not_contains: String
  email_not_ends_with: String
  email_not_in: [String!]
  email_not_starts_with: String
  email_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  locations_every: LocationWhereInput
  locations_none: LocationWhereInput
  locations_some: LocationWhereInput
  NOT: [SchoolWhereInput!]
  OR: [SchoolWhereInput!]
  owner: OwnerWhereInput
  phone: String
  phone_contains: String
  phone_ends_with: String
  phone_gt: String
  phone_gte: String
  phone_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_not: String
  phone_not_contains: String
  phone_not_ends_with: String
  phone_not_in: [String!]
  phone_not_starts_with: String
  phone_starts_with: String
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
  uri: String
  uri_contains: String
  uri_ends_with: String
  uri_gt: String
  uri_gte: String
  uri_in: [String!]
  uri_lt: String
  uri_lte: String
  uri_not: String
  uri_not_contains: String
  uri_not_ends_with: String
  uri_not_in: [String!]
  uri_not_starts_with: String
  uri_starts_with: String
}

input SchoolWhereUniqueInput {
  email: String
  id: ID
  phone: String
  uri: String
}

type Token {
  id: ID!
  token: String!
}

type TokenConnection {
  aggregate: AggregateToken!
  edges: [TokenEdge!]!
  pageInfo: PageInfo!
}

type TokenEdge {
  cursor: String!
  node: Token!
}

enum TokenOrderByInput {
  accountId_ASC
  accountId_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  token_ASC
  token_DESC
  type_ASC
  type_DESC
  updatedAt_ASC
  updatedAt_DESC
}

enum TokenType {
  EMAIL
  PASSWORD
}

input TokenWhereInput {
  accountId: String
  accountId_contains: String
  accountId_ends_with: String
  accountId_gt: String
  accountId_gte: String
  accountId_in: [String!]
  accountId_lt: String
  accountId_lte: String
  accountId_not: String
  accountId_not_contains: String
  accountId_not_ends_with: String
  accountId_not_in: [String!]
  accountId_not_starts_with: String
  accountId_starts_with: String
  AND: [TokenWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [TokenWhereInput!]
  OR: [TokenWhereInput!]
  token: String
  token_contains: String
  token_ends_with: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_ends_with: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_starts_with: String
  type: TokenType
  type_in: [TokenType!]
  type_not: TokenType
  type_not_in: [TokenType!]
}

input TokenWhereUniqueInput {
  id: ID
  token: String
}

type TriggerAction {
  ok: Boolean
}
